import { randomUUID } from 'crypto';

export type MedicalOrderState = 'draft' | 'pending' | 'under_review' | 'approved' | 'rejected' | 'partially_approved' | 'processing' | 'completed' | 'cancelled';
export type UrgencyLevel = 'low' | 'normal' | 'high' | 'urgent' | 'critical';
export type RequesterType = 'admin' | 'doctor' | 'auditor';
export type AuthorizationType = 'manual' | 'automatic' | 'hybrid';
export type AuthorizationStatus = 'pending' | 'approved' | 'rejected' | 'partial';

export interface MedicalOrderItem {
  itemId: string;
  categoryId: string;
  itemType: 'medication' | 'equipment' | 'supply';
  itemName: string;
  itemCode?: string;
  itemDescription?: string;
  requestedQuantity: number;
  approvedQuantity?: number;
  unitOfMeasure: string;
  brand?: string;
  presentation?: string;
  concentration?: string;
  administrationRoute?: string;
  medicalJustification?: string;
  estimatedUnitCost?: number;
  itemStatus: 'pending' | 'approved' | 'rejected' | 'partial';
  rejectionReason?: string;
}

export interface AIAnalysisResult {
  decision: 'approved' | 'rejected' | 'partial' | 'requires_review';
  confidence: number;
  reasoning: string;
  itemAnalysis: {
    itemId: string;
    decision: 'approved' | 'rejected' | 'partial' | 'requires_review';
    approvedQuantity?: number;
    reasoning: string;
  }[];
  riskFactors: string[];
  recommendations: string[];
}

export class MedicalOrder {
  constructor(
    public readonly orderId: string,
    public readonly orderNumber: string,
    public readonly requesterId: string,
    public readonly requesterType: RequesterType,
    public readonly affiliateId: string,
    public readonly healthcareProviderId: string | null,
    public readonly stateId: number,
    public readonly urgencyId: number,
    public readonly title: string,
    public readonly description: string | null,
    public readonly medicalJustification: string,
    public readonly diagnosis: string | null,
    public readonly treatmentPlan: string | null,
    public readonly estimatedDurationDays: number | null,
    public readonly items: MedicalOrderItem[],
    public readonly hasAttachments: boolean,
    public readonly estimatedCost: number | null,
    public readonly approvedCost: number | null,
    public readonly rejectionReason: string | null,
    public readonly authorizationType: AuthorizationType | null,
    public readonly authorizationStatus: AuthorizationStatus,
    public readonly authorizedBy: string | null,
    public readonly authorizedAt: Date | null,
    public readonly authorizationNotes: string | null,
    public readonly aiAnalysisResult: AIAnalysisResult | null,
    public readonly aiConfidenceScore: number | null,
    public readonly aiAnalyzedAt: Date | null,
    public readonly createdAt: Date,
    public readonly updatedAt: Date,
    public readonly createdBy: string,
    public readonly updatedBy: string | null
  ) {}

  static create(
    requesterId: string,
    requesterType: RequesterType,
    affiliateId: string,
    urgencyId: number,
    title: string,
    medicalJustification: string,
    items: Omit<MedicalOrderItem, 'itemId' | 'itemStatus'>[],
    options: {
      orderId?: string;
      orderNumber?: string;
      healthcareProviderId?: string;
      description?: string;
      diagnosis?: string;
      treatmentPlan?: string;
      estimatedDurationDays?: number;
      hasAttachments?: boolean;
      estimatedCost?: number;
      authorizationType?: AuthorizationType;
    } = {}
  ): MedicalOrder {
    const now = new Date();
    const orderId = options.orderId || randomUUID();
    
    const orderItems: MedicalOrderItem[] = items.map(item => ({
      ...item,
      itemId: randomUUID(),
      itemStatus: 'pending' as const
    }));

    return new MedicalOrder(
      orderId,
      options.orderNumber || '', // Will be generated by database trigger
      requesterId,
      requesterType,
      affiliateId,
      options.healthcareProviderId || null,
      1, // Default to 'draft' state
      urgencyId,
      title,
      options.description || null,
      medicalJustification,
      options.diagnosis || null,
      options.treatmentPlan || null,
      options.estimatedDurationDays || null,
      orderItems,
      options.hasAttachments || false,
      options.estimatedCost || null,
      null, // approvedCost
      null, // rejectionReason
      options.authorizationType || null,
      'pending', // authorizationStatus
      null, // authorizedBy
      null, // authorizedAt
      null, // authorizationNotes
      null, // aiAnalysisResult
      null, // aiConfidenceScore
      null, // aiAnalyzedAt
      now,
      now,
      requesterId,
      null
    );
  }

  // Business logic methods
  canBeModified(): boolean {
    return ['draft', 'pending'].includes(this.getStateName());
  }

  canBeAuthorized(): boolean {
    return ['pending', 'under_review'].includes(this.getStateName());
  }

  canBeCancelled(): boolean {
    return !['completed', 'cancelled'].includes(this.getStateName());
  }

  isUrgent(): boolean {
    return this.urgencyId >= 4; // urgent or critical
  }

  requiresManualReview(): boolean {
    return this.isUrgent() || 
           this.getTotalEstimatedCost() > 100000 ||
           this.items.some(item => item.itemType === 'equipment');
  }

  getTotalEstimatedCost(): number {
    return this.items.reduce((total, item) => {
      const itemCost = (item.estimatedUnitCost || 0) * item.requestedQuantity;
      return total + itemCost;
    }, 0);
  }

  getTotalApprovedCost(): number {
    return this.items.reduce((total, item) => {
      if (item.itemStatus === 'approved' && item.approvedQuantity && item.estimatedUnitCost) {
        return total + (item.estimatedUnitCost * item.approvedQuantity);
      }
      return total;
    }, 0);
  }

  getApprovedItemsCount(): number {
    return this.items.filter(item => item.itemStatus === 'approved').length;
  }

  getRejectedItemsCount(): number {
    return this.items.filter(item => item.itemStatus === 'rejected').length;
  }

  // State management
  approve(authorizedBy: string, notes?: string): MedicalOrder {
    if (!this.canBeAuthorized()) {
      throw new Error(`Cannot authorize order in state: ${this.getStateName()}`);
    }

    const approvedItems = this.items.map(item => ({
      ...item,
      itemStatus: 'approved' as const,
      approvedQuantity: item.requestedQuantity
    }));

    return this.updateAuthorizationStatus('approved', authorizedBy, notes, approvedItems);
  }

  reject(authorizedBy: string, reason: string, notes?: string): MedicalOrder {
    if (!this.canBeAuthorized()) {
      throw new Error(`Cannot reject order in state: ${this.getStateName()}`);
    }

    const rejectedItems = this.items.map(item => ({
      ...item,
      itemStatus: 'rejected' as const,
      rejectionReason: reason
    }));

    return this.updateAuthorizationStatus('rejected', authorizedBy, notes, rejectedItems, reason);
  }

  partialApprove(authorizedBy: string, itemApprovals: { itemId: string; approved: boolean; approvedQuantity?: number; rejectionReason?: string }[], notes?: string): MedicalOrder {
    if (!this.canBeAuthorized()) {
      throw new Error(`Cannot partially approve order in state: ${this.getStateName()}`);
    }

    const updatedItems = this.items.map(item => {
      const approval = itemApprovals.find(a => a.itemId === item.itemId);
      if (!approval) return item;

      return {
        ...item,
        itemStatus: approval.approved ? 'approved' as const : 'rejected' as const,
        approvedQuantity: approval.approved ? (approval.approvedQuantity || item.requestedQuantity) : undefined,
        rejectionReason: approval.approved ? undefined : approval.rejectionReason
      };
    });

    return this.updateAuthorizationStatus('partial', authorizedBy, notes, updatedItems);
  }

  applyAIAnalysis(analysisResult: AIAnalysisResult): MedicalOrder {
    const updatedItems = this.items.map(item => {
      const itemAnalysis = analysisResult.itemAnalysis.find(a => a.itemId === item.itemId);
      if (!itemAnalysis) return item;

      // Convert 'requires_review' to 'pending' for item status
      const itemStatus = itemAnalysis.decision === 'requires_review' ? 'pending' : itemAnalysis.decision;

      return {
        ...item,
        itemStatus: itemStatus as 'pending' | 'approved' | 'rejected' | 'partial',
        approvedQuantity: itemAnalysis.approvedQuantity,
        rejectionReason: itemAnalysis.decision === 'rejected' ? itemAnalysis.reasoning : undefined
      };
    });

    const authStatus: AuthorizationStatus = analysisResult.decision === 'requires_review' ? 'pending' : 
                                          analysisResult.decision === 'partial' ? 'partial' : 
                                          analysisResult.decision;

    return new MedicalOrder(
      this.orderId,
      this.orderNumber,
      this.requesterId,
      this.requesterType,
      this.affiliateId,
      this.healthcareProviderId,
      authStatus === 'approved' ? 3 : authStatus === 'rejected' ? 5 : 2, // Update state based on AI decision
      this.urgencyId,
      this.title,
      this.description,
      this.medicalJustification,
      this.diagnosis,
      this.treatmentPlan,
      this.estimatedDurationDays,
      updatedItems,
      this.hasAttachments,
      this.estimatedCost,
      authStatus === 'approved' ? this.getTotalApprovedCost() : null,
      authStatus === 'rejected' ? analysisResult.reasoning : null,
      'automatic',
      authStatus,
      null, // AI doesn't set authorized_by
      authStatus !== 'pending' ? new Date() : null,
      analysisResult.reasoning,
      analysisResult,
      analysisResult.confidence,
      new Date(),
      this.createdAt,
      new Date(),
      this.createdBy,
      this.updatedBy
    );
  }

  private updateAuthorizationStatus(
    status: AuthorizationStatus, 
    authorizedBy: string, 
    notes?: string, 
    items?: MedicalOrderItem[], 
    rejectionReason?: string
  ): MedicalOrder {
    const stateId = status === 'approved' ? 4 : status === 'rejected' ? 5 : status === 'partial' ? 6 : this.stateId;
    
    return new MedicalOrder(
      this.orderId,
      this.orderNumber,
      this.requesterId,
      this.requesterType,
      this.affiliateId,
      this.healthcareProviderId,
      stateId,
      this.urgencyId,
      this.title,
      this.description,
      this.medicalJustification,
      this.diagnosis,
      this.treatmentPlan,
      this.estimatedDurationDays,
      items || this.items,
      this.hasAttachments,
      this.estimatedCost,
      status === 'approved' ? this.getTotalApprovedCost() : this.approvedCost,
      rejectionReason || this.rejectionReason,
      'manual',
      status,
      authorizedBy,
      new Date(),
      notes,
      this.aiAnalysisResult,
      this.aiConfidenceScore,
      this.aiAnalyzedAt,
      this.createdAt,
      new Date(),
      this.createdBy,
      authorizedBy
    );
  }

  // Helper methods
  private getStateName(): string {
    const states: { [key: number]: string } = {
      1: 'draft',
      2: 'pending',
      3: 'under_review',
      4: 'approved',
      5: 'rejected',
      6: 'partially_approved',
      7: 'processing',
      8: 'completed',
      9: 'cancelled'
    };
    return states[this.stateId] || 'unknown';
  }

  // Validation methods
  validate(): string[] {
    const errors: string[] = [];

    if (!this.title.trim()) {
      errors.push('Title is required');
    }

    if (!this.medicalJustification.trim()) {
      errors.push('Medical justification is required');
    }

    if (this.items.length === 0) {
      errors.push('At least one item is required');
    }

    this.items.forEach((item, index) => {
      if (!item.itemName.trim()) {
        errors.push(`Item ${index + 1}: Name is required`);
      }
      if (item.requestedQuantity <= 0) {
        errors.push(`Item ${index + 1}: Quantity must be greater than 0`);
      }
      if (!item.unitOfMeasure.trim()) {
        errors.push(`Item ${index + 1}: Unit of measure is required`);
      }
    });

    return errors;
  }

  isValid(): boolean {
    return this.validate().length === 0;
  }
} 